from matplotlib import pyplot as plt
import numpy as np


def potato(data, bboxs, i, pboxs, x_lim_min, x_lim_max, y_lim_min, y_lim_max):

    for h in range(0, len(data['trace'])):  # data['trace'] is a list of traces; each element contains a trace, and each trace has a list of [x, y] coordinates
        x = []
        y = []
        for j in range(0, len(data['trace'][h])):  # Returns j-th point of each trace
            x.append(data['trace'][h][j][0])  # Returns x coordinate of the j-th point of each trace
            y.append(data['trace'][h][j][1])  # Returns y coordinate of the j-th point of each trace
        plt.plot(x, y, color='black', linewidth=0.6)  # Plots current trace in plain black
    plt.axis('equal')  # Constrains proportions
    plt.axis('off')  # Removes axes from figure

    xlim = plt.gca().get_xlim()  # xlim = [0, 1531.84995+468.15104999999994]
    ylim = plt.gca().get_ylim()  # ylim = [0, 2200]

    coord_x = [bboxs['x_min'][i], bboxs['x_max'][i], bboxs['x_max'][i], bboxs['x_min'][i], bboxs['x_min'][i]]
    coord_y = [bboxs['y_max'][i], bboxs['y_max'][i], bboxs['y_min'][i], bboxs['y_min'][i], bboxs['y_max'][i]]

    fig, ax = plt.subplots()
    points, = ax.plot(coord_x, coord_y, 'ro')  # 'ro' Ã¨ il colore (pallini rossi); l'array sono le y dei punti
    ax.axis('scaled')
    # ax.axis([xlim[0], xlim[1], ylim[0], ylim[1]])
    ax.set_xlim(xlim[0], xlim[1])
    ax.set_ylim(ylim[0], ylim[1])

    # Get the x and y data and transform it into pixel coordinates
    x, y = points.get_data()
    fig.canvas.draw()

    '''
    print()
    print([x, y])
    print(np.vstack([x, y]))
    print(np.vstack([x, y]).T)
    print()
    '''


    xy_pixels = ax.transData.transform(np.vstack([x, y]).T)
    xpix, ypix = xy_pixels.T


    # In matplotlib, 0,0 is the lower left corner, whereas it's usually the upper
    # left for most image software, so we'll flip the y-coords...
    width, height = fig.canvas.get_width_height()
    ypix = height - ypix

    print('.', end='')
    #print('Coordinates of the points in pixel coordinates...')
    #for xp, yp in zip(xpix, ypix):
    #    print('{x:0.0f}\t{y:0.0f}'.format(x=xp, y=yp))

    plt.close()  # Closes the plot generated by axe (it is only needed to calculate pixel coordinates)

    xpix.sort()
    ypix.sort()

    pboxs = pboxs.append({'x_min': xpix[0], 'x_max': xpix[len(xpix) - 1], 'y_min': ypix[0], 'y_max': ypix[len(ypix) - 1]}, ignore_index=True)

    return pboxs
